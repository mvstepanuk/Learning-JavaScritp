cL(factorial(5))

try {
  // В нормальной ситуации этот код выполняется от начала до конца блока
  // безо всяких проблем. Но иногда он может генерировать исключение,
  // либо напрямую с помощью оператора throw, либо косвенно за счет вызова
  // метода, который генерирует исключение.
} catch (e) {
  // Операторы в данном блоке выполняются, если и только если в блоке try
  // было сгенерировано исключение. Эти операторы могут использовать
  // локальную переменную е для ссылки на объект Error или другое значение,
  // которое было указано в throw. В блоке можно каким-то образом
  // обработать исключение, проигнорировать его, ничего не делая,
  // или повторно сгенерировать исключение с помощью throw.
} finally {
  // Данный блок содержит операторы, которые всегда выполняются
  // независимо от того, что произошло в блоке try.
  // Они выполняются при завершении блока try:
  // 1) нормальным образом после того, как достигнут конец блока;
  // 2) из-за оператора break, continue или return;
  // 3) из-за исключения, которое было обработано конструкцией catch выше;
  // 4) из-за необработанного исключения, которое продолжило
  // свое распространение
}

try {
  // Запросить у пользователя ввод числа
  // eslint-disable-next-line prefer-const
  let n = Number(prompt('Введите положительное число', ''))
  // Вычислить факториал числа, предполагая, что введенное число допустимо
  // eslint-disable-next-line prefer-const
  let f = factorial(n)
  // Вывести результат
  alert(n + '! = ' + f)
} catch (ex) {
  // Если введенное пользователем число было
  // недопустимым, то мы оказываемся здесь
  alert(ex) // Сообщить пользователю об ошибке
}

function cL (x) { console.log(x) }

function factorial (x) {
  if (x < 0) throw new Error('Значение x не должно быть отрицательным')
  let f
  for (f = 1; x > 1; f *= x, x--) /* пустое тело */ ;
  return f
}
